
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>btclient: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bittensor-lab/btsigner/cmd/btclient/main.go (0.0%)</option>
				
				<option value="file1">github.com/bittensor-lab/btsigner/cmd/btsigner/main.go (0.0%)</option>
				
				<option value="file2">github.com/bittensor-lab/btsigner/internal/config/config.go (100.0%)</option>
				
				<option value="file3">github.com/bittensor-lab/btsigner/internal/crypto/keystore.go (86.4%)</option>
				
				<option value="file4">github.com/bittensor-lab/btsigner/internal/crypto/sr25519.go (83.3%)</option>
				
				<option value="file5">github.com/bittensor-lab/btsigner/internal/crypto/ss58.go (96.4%)</option>
				
				<option value="file6">github.com/bittensor-lab/btsigner/pkg/client/client.go (100.0%)</option>
				
				<option value="file7">github.com/bittensor-lab/btsigner/pkg/server/health.go (100.0%)</option>
				
				<option value="file8">github.com/bittensor-lab/btsigner/pkg/server/server.go (60.3%)</option>
				
				<option value="file9">github.com/bittensor-lab/btsigner/pkg/signer/keystore_signer.go (85.0%)</option>
				
				<option value="file10">github.com/bittensor-lab/btsigner/pkg/signer/signer.go (79.2%)</option>
				
				<option value="file11">github.com/bittensor-lab/btsigner/proto/signer/v1/signer.pb.go (0.0%)</option>
				
				<option value="file12">github.com/bittensor-lab/btsigner/proto/signer/v1/signer_grpc.pb.go (0.0%)</option>
				
				<option value="file13">github.com/bittensor-lab/btsigner/scripts/test_keygen_and_signing.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "encoding/hex"
        "flag"
        "fmt"
        "os"

        "github.com/bittensor-lab/btsigner/pkg/client"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        address := flag.String("address", "localhost:50051", "Address of the remote signer")
        tls := flag.Bool("tls", false, "Use TLS")
        caFile := flag.String("ca", "", "Path to CA certificate")
        certFile := flag.String("cert", "", "Path to client certificate")
        serverName := flag.String("server-name", "", "Server name override for TLS")

        getPublicKey := flag.Bool("get-public-key", false, "Get the public key")
        sign := flag.String("sign", "", "Sign a payload (hex encoded)")
        keyID := flag.String("key-id", "", "Key ID to use for signing (optional)")
        health := flag.Bool("health", false, "Check server health")

        flag.Parse()

        // Create client options
        opts := client.DefaultClientOptions()
        opts.Address = *address
        opts.TLSEnabled = *tls
        opts.CAPath = *caFile
        opts.CertPath = *certFile
        opts.ServerNameOverride = *serverName

        // Create client
        c, err := client.NewSignerClient(opts)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to create client: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer c.Close()

        ctx := context.Background()

        // Execute requested command
        if *getPublicKey </span><span class="cov0" title="0">{
                pubKey, ss58Addr, err := c.GetPublicKey(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to get public key: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Public Key: %x\n", pubKey)
                fmt.Printf("SS58 Address: %s\n", ss58Addr)</span>
        } else<span class="cov0" title="0"> if *sign != "" </span><span class="cov0" title="0">{
                payload, err := hex.DecodeString(*sign)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to decode payload: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">var signature []byte
                if *keyID != "" </span><span class="cov0" title="0">{
                        // Sign with specific key
                        signature, err = c.SignExtrinsicWithKey(ctx, *keyID, payload)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Failed to sign payload with key %s: %v\n", *keyID, err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Signing with key: %s\n", *keyID)</span>
                } else<span class="cov0" title="0"> {
                        // Sign with default key
                        signature, err = c.SignExtrinsic(ctx, payload)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Failed to sign payload: %v\n", err)
                                os.Exit(1)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("Signature: %x\n", signature)</span>
        } else<span class="cov0" title="0"> if *health </span><span class="cov0" title="0">{
                if err := c.CheckHealth(ctx); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Health check failed: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Println("Server is healthy")</span>
        } else<span class="cov0" title="0"> {
                flag.Usage()
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "syscall"

        "github.com/bittensor-lab/btsigner/internal/config"
        "github.com/bittensor-lab/btsigner/internal/crypto"
        "github.com/bittensor-lab/btsigner/pkg/server"
        "github.com/bittensor-lab/btsigner/pkg/signer"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "golang.org/x/term"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        configPath := flag.String("config", "config.yaml", "Path to configuration file")
        keyPath := flag.String("key", "", "Path to key file (overrides config)")
        keyStorePath := flag.String("keystore", "", "Path to key store directory (enables multi-key support)")
        keyID := flag.String("key-id", "", "Key ID to use (with keystore)")
        genKey := flag.Bool("genkey", false, "Generate a new key")
        checkKey := flag.Bool("check-key", false, "Check a key without starting the server")
        flag.Parse()

        // Initialize logger
        logConfig := zap.NewProductionConfig()
        logConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        logger, err := logConfig.Build()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logger.Sync()

        // Load configuration
        cfg, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to load configuration", zap.Error(err))
        }</span>

        // Override key path if specified
        <span class="cov0" title="0">if *keyPath != "" </span><span class="cov0" title="0">{
                cfg.Key.Path = *keyPath
        }</span>

        <span class="cov0" title="0">var signerImpl signer.Signer

        // Check if using keystore
        if *keyStorePath != "" </span><span class="cov0" title="0">{
                // Use KeyStoreSigner for multi-key support
                keyStoreSigner, err := signer.NewKeyStoreSigner(*keyStorePath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to create key store signer", zap.Error(err))
                }</span>

                // Generate a new key if requested
                <span class="cov0" title="0">if *genKey </span><span class="cov0" title="0">{
                        if *keyID == "" </span><span class="cov0" title="0">{
                                logger.Fatal("Key ID is required when generating a key in a key store")
                        }</span>

                        <span class="cov0" title="0">var password, confirmPassword []byte

                        // Check for password in environment variable (for testing)
                        if envPassword := os.Getenv("BTSIGNER_PASSWORD"); envPassword != "" </span><span class="cov0" title="0">{
                                password = []byte(envPassword)

                                // Check for confirmation password in environment variable
                                if envConfirmPassword := os.Getenv("BTSIGNER_CONFIRM_PASSWORD"); envConfirmPassword != "" </span><span class="cov0" title="0">{
                                        confirmPassword = []byte(envConfirmPassword)
                                }</span> else<span class="cov0" title="0"> {
                                        confirmPassword = password // Use same password if confirmation not provided
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Interactive password entry
                                fmt.Print("Enter password for new key: ")
                                password, err = term.ReadPassword(int(syscall.Stdin))
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to read password", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">fmt.Println()

                                fmt.Print("Confirm password: ")
                                confirmPassword, err = term.ReadPassword(int(syscall.Stdin))
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to read password confirmation", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">if string(password) != string(confirmPassword) </span><span class="cov0" title="0">{
                                logger.Fatal("Passwords do not match")
                        }</span>

                        <span class="cov0" title="0">err = keyStoreSigner.GenerateKey(*keyID, password)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to generate key",
                                        zap.String("key_id", *keyID),
                                        zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">_, ss58Addr, err := keyStoreSigner.GetPublicKeyByID(*keyID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to get public key",
                                        zap.String("key_id", *keyID),
                                        zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">logger.Info("Generated new key",
                                zap.String("key_id", *keyID),
                                zap.String("ss58_address", ss58Addr))

                        return</span>
                }

                // If key ID is specified, load that key
                <span class="cov0" title="0">if *keyID != "" </span><span class="cov0" title="0">{
                        var password []byte

                        // Check for password in environment variable (for testing)
                        if envPassword := os.Getenv("BTSIGNER_PASSWORD"); envPassword != "" </span><span class="cov0" title="0">{
                                password = []byte(envPassword)
                        }</span> else<span class="cov0" title="0"> {
                                // Interactive password entry
                                fmt.Printf("Enter password to unlock key %s: ", *keyID)
                                password, err = term.ReadPassword(int(syscall.Stdin))
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to read password", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">err = keyStoreSigner.LoadKey(*keyID, password)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to load key",
                                        zap.String("key_id", *keyID),
                                        zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">keyStoreSigner.SetDefaultKeyID(*keyID)

                        // Check key and exit if requested
                        if *checkKey </span><span class="cov0" title="0">{
                                _, ss58Addr, err := keyStoreSigner.GetPublicKeyByID(*keyID)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to get public key",
                                                zap.String("key_id", *keyID),
                                                zap.Error(err))
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("Key ID: %s\n", *keyID)
                                fmt.Printf("SS58 Address: %s\n", ss58Addr)
                                return</span>
                        }
                } else<span class="cov0" title="0"> {
                        // List available keys
                        keyIDs := keyStoreSigner.ListKeyIDs()
                        if len(keyIDs) == 0 </span><span class="cov0" title="0">{
                                logger.Fatal("No keys found in key store. Use -genkey to generate a new key.")
                        }</span>

                        <span class="cov0" title="0">fmt.Println("Available keys:")
                        for _, id := range keyIDs </span><span class="cov0" title="0">{
                                fmt.Printf("- %s\n", id)
                        }</span>

                        <span class="cov0" title="0">fmt.Print("Enter key ID to use: ")
                        var selectedKeyID string
                        fmt.Scanln(&amp;selectedKeyID)

                        var password []byte

                        // Check for password in environment variable (for testing)
                        if envPassword := os.Getenv("BTSIGNER_PASSWORD"); envPassword != "" </span><span class="cov0" title="0">{
                                password = []byte(envPassword)
                        }</span> else<span class="cov0" title="0"> {
                                // Interactive password entry
                                fmt.Printf("Enter password to unlock key %s: ", selectedKeyID)
                                password, err = term.ReadPassword(int(syscall.Stdin))
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to read password", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">err = keyStoreSigner.LoadKey(selectedKeyID, password)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to load key",
                                        zap.String("key_id", selectedKeyID),
                                        zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">keyStoreSigner.SetDefaultKeyID(selectedKeyID)</span>
                }

                <span class="cov0" title="0">signerImpl = keyStoreSigner</span>
        } else<span class="cov0" title="0"> {
                // Use traditional single key signer
                // Generate a new key if requested
                if *genKey </span><span class="cov0" title="0">{
                        var password, confirmPassword []byte

                        // Check for password in environment variable (for testing)
                        if envPassword := os.Getenv("BTSIGNER_PASSWORD"); envPassword != "" </span><span class="cov0" title="0">{
                                password = []byte(envPassword)

                                // Check for confirmation password in environment variable
                                if envConfirmPassword := os.Getenv("BTSIGNER_CONFIRM_PASSWORD"); envConfirmPassword != "" </span><span class="cov0" title="0">{
                                        confirmPassword = []byte(envConfirmPassword)
                                }</span> else<span class="cov0" title="0"> {
                                        confirmPassword = password // Use same password if confirmation not provided
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Interactive password entry
                                fmt.Print("Enter password for new key: ")
                                password, err = term.ReadPassword(int(syscall.Stdin))
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to read password", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">fmt.Println()

                                fmt.Print("Confirm password: ")
                                confirmPassword, err = term.ReadPassword(int(syscall.Stdin))
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to read password confirmation", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }

                        <span class="cov0" title="0">if string(password) != string(confirmPassword) </span><span class="cov0" title="0">{
                                logger.Fatal("Passwords do not match")
                        }</span>

                        <span class="cov0" title="0">keyPair, err := crypto.GenerateKeyFile(cfg.Key.Path, password)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to generate key", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">pubKey := keyPair.PublicKey()
                        ss58Addr, err := crypto.PublicKeyToSS58(pubKey)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to convert public key to SS58", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">logger.Info("Generated new key",
                                zap.String("path", cfg.Key.Path),
                                zap.String("ss58_address", ss58Addr))

                        return</span>
                }

                // Get password
                <span class="cov0" title="0">var password []byte

                // Check for password in environment variable (for testing)
                if envPassword := os.Getenv("BTSIGNER_PASSWORD"); envPassword != "" </span><span class="cov0" title="0">{
                        password = []byte(envPassword)
                }</span> else<span class="cov0" title="0"> {
                        // Interactive password entry
                        fmt.Print("Enter password to unlock key: ")
                        password, err = term.ReadPassword(int(syscall.Stdin))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to read password", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                // Create signer
                <span class="cov0" title="0">signerImpl, err = signer.NewSr25519Signer(cfg.Key.Path, password)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to create signer", zap.Error(err))
                }</span>

                // Check key and exit if requested
                <span class="cov0" title="0">if *checkKey </span><span class="cov0" title="0">{
                        _, ss58Addr, err := signerImpl.GetPublicKey()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to get public key", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Key Path: %s\n", cfg.Key.Path)
                        fmt.Printf("SS58 Address: %s\n", ss58Addr)
                        return</span>
                }
        }

        <span class="cov0" title="0">defer signerImpl.Close()

        // Get public key for logging
        _, ss58Addr, err := signerImpl.GetPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to get public key", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Loaded key", zap.String("ss58_address", ss58Addr))

        // Create and run server
        srv := server.NewServer(signerImpl, cfg, logger)
        if err := srv.Run(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Server error", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

// Config holds the application configuration
type Config struct {
        Server struct {
                Address string `yaml:"address" json:"address"`
        } `yaml:"server" json:"server"`

        Key struct {
                Path     string `yaml:"path" json:"path"`
                Type     string `yaml:"type" json:"type"` // file, vault, kms
                VaultURL string `yaml:"vault_url" json:"vault_url,omitempty"`
                VaultKey string `yaml:"vault_key" json:"vault_key,omitempty"`
        } `yaml:"key" json:"key"`

        TLS struct {
                Enabled    bool   `yaml:"enabled" json:"enabled"`
                CertPath   string `yaml:"cert_path" json:"cert_path"`
                KeyPath    string `yaml:"key_path" json:"key_path"`
                ClientAuth bool   `yaml:"client_auth" json:"client_auth"`
                CAPath     string `yaml:"ca_path" json:"ca_path"`
        } `yaml:"tls" json:"tls"`

        Metrics struct {
                Enabled bool   `yaml:"enabled" json:"enabled"`
                Address string `yaml:"address" json:"address"`
        } `yaml:"metrics" json:"metrics"`

        Log struct {
                Level  string `yaml:"level" json:"level"`
                Format string `yaml:"format" json:"format"` // json, console
        } `yaml:"log" json:"log"`
}

// LoadConfig loads configuration from a file
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg Config

        // Determine file format based on extension
        switch filepath.Ext(path) </span>{
        case ".yaml", ".yml":<span class="cov8" title="1">
                if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse YAML config: %w", err)
                }</span>
        case ".json":<span class="cov8" title="1">
                if err := json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse JSON config: %w", err)
                }</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported config format: %s", filepath.Ext(path))</span>
        }

        // Apply defaults
        <span class="cov8" title="1">if cfg.Server.Address == "" </span><span class="cov8" title="1">{
                cfg.Server.Address = ":50051"
        }</span>

        <span class="cov8" title="1">if cfg.Metrics.Enabled &amp;&amp; cfg.Metrics.Address == "" </span><span class="cov8" title="1">{
                cfg.Metrics.Address = ":9090"
        }</span>

        <span class="cov8" title="1">if cfg.Log.Level == "" </span><span class="cov8" title="1">{
                cfg.Log.Level = "info"
        }</span>

        <span class="cov8" title="1">if cfg.Log.Format == "" </span><span class="cov8" title="1">{
                cfg.Log.Format = "json"
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// DefaultConfig returns a default configuration
func DefaultConfig() *Config <span class="cov8" title="1">{
        cfg := &amp;Config{}

        cfg.Server.Address = ":50051"
        cfg.Key.Type = "file"
        cfg.Key.Path = "key.json"
        cfg.TLS.Enabled = false
        cfg.Metrics.Enabled = true
        cfg.Metrics.Address = ":9090"
        cfg.Log.Level = "info"
        cfg.Log.Format = "json"

        return cfg
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package crypto

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

var (
        ErrKeyIDNotFound  = errors.New("key ID not found")
        ErrKeyIDExists    = errors.New("key ID already exists")
        ErrMaxKeysReached = errors.New("maximum number of keys reached (256)")
        ErrInvalidKeyID   = errors.New("invalid key ID")
)

// KeyStoreMetadata holds metadata about the keys in the store
type KeyStoreMetadata struct {
        Version    int               `json:"version"`
        KeyCount   int               `json:"key_count"`
        KeyEntries map[string]string `json:"key_entries"` // Maps key ID to filename
}

// KeyStore manages multiple Sr25519KeyPair instances
type KeyStore struct {
        basePath string
        metadata KeyStoreMetadata
        keys     map[string]*Sr25519KeyPair
        mu       sync.RWMutex
}

// NewKeyStore creates a new key store at the specified directory
func NewKeyStore(basePath string) (*KeyStore, error) <span class="cov8" title="1">{
        // Create directory if it doesn't exist
        if err := os.MkdirAll(basePath, 0700); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create key store directory: %w", err)
        }</span>

        <span class="cov8" title="1">metadataPath := filepath.Join(basePath, "metadata.json")
        metadata := KeyStoreMetadata{
                Version:    1,
                KeyCount:   0,
                KeyEntries: make(map[string]string),
        }

        // Try to load existing metadata
        if _, err := os.Stat(metadataPath); err == nil </span><span class="cov8" title="1">{
                data, err := os.ReadFile(metadataPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read metadata: %w", err)
                }</span>

                <span class="cov8" title="1">if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse metadata: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Create new metadata file
                data, err := json.MarshalIndent(metadata, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal metadata: %w", err)
                }</span>

                <span class="cov8" title="1">if err := os.WriteFile(metadataPath, data, 0600); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to write metadata: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;KeyStore{
                basePath: basePath,
                metadata: metadata,
                keys:     make(map[string]*Sr25519KeyPair),
        }, nil</span>
}

// saveMetadata saves the key store metadata to disk
func (ks *KeyStore) saveMetadata() error <span class="cov8" title="1">{
        metadataPath := filepath.Join(ks.basePath, "metadata.json")
        data, err := json.MarshalIndent(ks.metadata, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov8" title="1">return os.WriteFile(metadataPath, data, 0600)</span>
}

// GenerateKey generates a new key with the given ID and password
func (ks *KeyStore) GenerateKey(id string, password []byte) (*Sr25519KeyPair, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidKeyID
        }</span>

        <span class="cov8" title="1">ks.mu.Lock()
        defer ks.mu.Unlock()

        // Check if ID already exists
        if _, exists := ks.metadata.KeyEntries[id]; exists </span><span class="cov8" title="1">{
                return nil, ErrKeyIDExists
        }</span>

        // Check if we've reached the maximum number of keys (256)
        <span class="cov8" title="1">if len(ks.metadata.KeyEntries) &gt;= 256 </span><span class="cov0" title="0">{
                return nil, ErrMaxKeysReached
        }</span>

        // Generate key filename
        <span class="cov8" title="1">keyFilename := fmt.Sprintf("key_%s.json", id)
        keyPath := filepath.Join(ks.basePath, keyFilename)

        // Generate the key
        keyPair, err := GenerateKeyFile(keyPath, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update metadata
        <span class="cov8" title="1">ks.metadata.KeyEntries[id] = keyFilename
        ks.metadata.KeyCount = len(ks.metadata.KeyEntries)

        // Save metadata
        if err := ks.saveMetadata(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in memory
        <span class="cov8" title="1">ks.keys[id] = keyPair

        return keyPair, nil</span>
}

// LoadKey loads a key with the given ID and password
func (ks *KeyStore) LoadKey(id string, password []byte) (*Sr25519KeyPair, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidKeyID
        }</span>

        <span class="cov8" title="1">ks.mu.Lock()
        defer ks.mu.Unlock()

        // Check if already loaded
        if keyPair, exists := ks.keys[id]; exists </span><span class="cov8" title="1">{
                return keyPair, nil
        }</span>

        // Check if ID exists in metadata
        <span class="cov8" title="1">keyFilename, exists := ks.metadata.KeyEntries[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, ErrKeyIDNotFound
        }</span>

        // Load the key
        <span class="cov8" title="1">keyPath := filepath.Join(ks.basePath, keyFilename)
        keyPair, err := LoadSr25519KeyPair(keyPath, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in memory
        <span class="cov8" title="1">ks.keys[id] = keyPair

        return keyPair, nil</span>
}

// UnloadKey removes a key from memory
func (ks *KeyStore) UnloadKey(id string) error <span class="cov8" title="1">{
        ks.mu.Lock()
        defer ks.mu.Unlock()

        keyPair, exists := ks.keys[id]
        if !exists </span><span class="cov8" title="1">{
                return nil // Already unloaded
        }</span>

        // Zero the key
        <span class="cov8" title="1">if err := keyPair.Zero(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remove from memory
        <span class="cov8" title="1">delete(ks.keys, id)

        return nil</span>
}

// DeleteKey permanently deletes a key from disk
func (ks *KeyStore) DeleteKey(id string) error <span class="cov8" title="1">{
        ks.mu.Lock()
        defer ks.mu.Unlock()

        // Check if ID exists in metadata
        keyFilename, exists := ks.metadata.KeyEntries[id]
        if !exists </span><span class="cov8" title="1">{
                return ErrKeyIDNotFound
        }</span>

        // Unload from memory if loaded
        <span class="cov8" title="1">if keyPair, loaded := ks.keys[id]; loaded </span><span class="cov8" title="1">{
                if err := keyPair.Zero(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">delete(ks.keys, id)</span>
        }

        // Delete the key file
        <span class="cov8" title="1">keyPath := filepath.Join(ks.basePath, keyFilename)
        if err := os.Remove(keyPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete key file: %w", err)
        }</span>

        // Update metadata
        <span class="cov8" title="1">delete(ks.metadata.KeyEntries, id)
        ks.metadata.KeyCount = len(ks.metadata.KeyEntries)

        // Save metadata
        return ks.saveMetadata()</span>
}

// ListKeyIDs returns a list of all key IDs in the store
func (ks *KeyStore) ListKeyIDs() []string <span class="cov8" title="1">{
        ks.mu.RLock()
        defer ks.mu.RUnlock()

        ids := make([]string, 0, len(ks.metadata.KeyEntries))
        for id := range ks.metadata.KeyEntries </span><span class="cov8" title="1">{
                ids = append(ids, id)
        }</span>

        <span class="cov8" title="1">return ids</span>
}

// GetKeyInfo returns information about a key
func (ks *KeyStore) GetKeyInfo(id string) ([]byte, string, error) <span class="cov8" title="1">{
        ks.mu.RLock()
        defer ks.mu.RUnlock()

        keyPair, exists := ks.keys[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, "", ErrKeyIDNotFound
        }</span>

        <span class="cov8" title="1">pubKey := keyPair.PublicKey()
        ss58Addr, err := PublicKeyToSS58(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                return pubKey, "", err
        }</span>

        <span class="cov8" title="1">return pubKey, ss58Addr, nil</span>
}

// Close unloads all keys from memory
func (ks *KeyStore) Close() error <span class="cov8" title="1">{
        ks.mu.Lock()
        defer ks.mu.Unlock()

        var lastErr error
        for id, keyPair := range ks.keys </span><span class="cov8" title="1">{
                if err := keyPair.Zero(); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                }</span>
                <span class="cov8" title="1">delete(ks.keys, id)</span>
        }

        <span class="cov8" title="1">return lastErr</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package crypto

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/ChainSafe/go-schnorrkel"
        "github.com/gtank/merlin"
        "golang.org/x/crypto/argon2"
)

var (
        ErrInvalidKeyFile = errors.New("invalid key file")
        ErrDecryptFailed  = errors.New("failed to decrypt key")
)

// KeyFile represents the encrypted key file format
type KeyFile struct {
        PublicKey  []byte `json:"public_key"`
        Ciphertext []byte `json:"ciphertext"`
        Nonce      []byte `json:"nonce"`
        Salt       []byte `json:"salt"`
        Version    int    `json:"version"`
}

// Sr25519KeyPair holds the keypair for sr25519 operations
type Sr25519KeyPair struct {
        secretKey *schnorrkel.MiniSecretKey
        publicKey []byte
}

// LoadSr25519KeyPair loads an sr25519 keypair from an encrypted file
func LoadSr25519KeyPair(path string, password []byte) (*Sr25519KeyPair, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read key file: %w", err)
        }</span>

        <span class="cov8" title="1">var keyFile KeyFile
        if err := json.Unmarshal(data, &amp;keyFile); err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidKeyFile
        }</span>

        // Derive key from password using Argon2id
        <span class="cov8" title="1">key := argon2.IDKey(password, keyFile.Salt, 1, 64*1024, 4, 32)

        // Decrypt the private key
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrDecryptFailed
        }</span>

        <span class="cov8" title="1">aesgcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrDecryptFailed
        }</span>

        <span class="cov8" title="1">privateKeyBytes, err := aesgcm.Open(nil, keyFile.Nonce, keyFile.Ciphertext, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrDecryptFailed
        }</span>

        // Create schnorrkel secret key
        <span class="cov8" title="1">var miniSecretKey [32]byte
        copy(miniSecretKey[:], privateKeyBytes)
        secretKey, err := schnorrkel.NewMiniSecretKeyFromRaw(miniSecretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid private key: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Sr25519KeyPair{
                secretKey: secretKey,
                publicKey: keyFile.PublicKey,
        }, nil</span>
}

// PublicKey returns the public key bytes
func (kp *Sr25519KeyPair) PublicKey() []byte <span class="cov8" title="1">{
        return kp.publicKey
}</span>

// Sign signs a message using sr25519
func (kp *Sr25519KeyPair) Sign(message []byte) ([]byte, error) <span class="cov8" title="1">{
        t := merlin.NewTranscript("substrate")
        t.AppendMessage([]byte("sign-message"), message)

        secretKey := kp.secretKey.ExpandEd25519()
        sig, err := secretKey.Sign(t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sigBytes := sig.Encode()
        return sigBytes[:], nil</span>
}

// Zero wipes the secret key material from memory
func (kp *Sr25519KeyPair) Zero() error <span class="cov8" title="1">{
        // This is a best-effort attempt to clear the memory
        // In Go, this isn't guaranteed due to GC and memory management
        if kp.secretKey != nil </span><span class="cov8" title="1">{
                // The schnorrkel library should provide a method to zero the key
                // For now, we'll rely on GC
                kp.secretKey = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GenerateKeyFile creates a new encrypted key file
func GenerateKeyFile(path string, password []byte) (*Sr25519KeyPair, error) <span class="cov8" title="1">{
        // Generate a new keypair
        miniSecretKey, err := schnorrkel.GenerateMiniSecretKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get the private key bytes
        <span class="cov8" title="1">privateKeyBytes := miniSecretKey.Encode()

        // Get the public key
        publicKey := miniSecretKey.Public().Encode()

        // Generate salt for key derivation
        salt := make([]byte, 16)
        if _, err := io.ReadFull(rand.Reader, salt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Derive encryption key from password
        <span class="cov8" title="1">key := argon2.IDKey(password, salt, 1, 64*1024, 4, 32)

        // Encrypt the private key
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">aesgcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, aesgcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ciphertext := aesgcm.Seal(nil, nonce, privateKeyBytes[:], nil)

        // Create key file
        keyFile := KeyFile{
                PublicKey:  publicKey[:],
                Ciphertext: ciphertext,
                Nonce:      nonce,
                Salt:       salt,
                Version:    1,
        }

        // Write to file
        data, err := json.Marshal(keyFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0600); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Sr25519KeyPair{
                secretKey: miniSecretKey,
                publicKey: publicKey[:],
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package crypto

import (
        "crypto/sha512"
        "errors"
        "fmt"
        "math/big"
)

const (
        // SS58Prefix is the prefix for Bittensor addresses
        SS58Prefix byte = 0x2A // 42 in decimal for Substrate/Polkadot
)

var (
        ErrInvalidPublicKey = errors.New("invalid public key")
)

// PublicKeyToSS58 converts a public key to SS58 address format for Bittensor
func PublicKeyToSS58(publicKey []byte) (string, error) <span class="cov8" title="1">{
        if len(publicKey) != 32 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%w: expected 32 bytes, got %d", ErrInvalidPublicKey, len(publicKey))
        }</span>

        // Create the SS58 format with prefix
        <span class="cov8" title="1">ss58Data := make([]byte, 0, 35) // prefix + pubkey + 2 checksum bytes
        ss58Data = append(ss58Data, SS58Prefix)
        ss58Data = append(ss58Data, publicKey...)

        // Calculate checksum
        checksumPrefix := []byte("SS58PRE")
        checksumData := append(checksumPrefix, ss58Data...)
        checksum := blake2b512(checksumData)
        ss58Data = append(ss58Data, checksum[:2]...)

        // Encode to base58
        address := base58Encode(ss58Data)
        return address, nil</span>
}

// blake2b512 calculates the Blake2b-512 hash
func blake2b512(data []byte) []byte <span class="cov8" title="1">{
        hash := sha512.Sum512(data)
        return hash[:]
}</span>

// Base58 alphabet used by SS58
const base58Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

// base58Encode encodes data to base58 format
func base58Encode(data []byte) string <span class="cov8" title="1">{
        var result []byte

        // Convert to big integer
        x := new(big.Int).SetBytes(data)
        base := big.NewInt(58)
        zero := big.NewInt(0)

        // Perform base58 encoding
        for x.Cmp(zero) &gt; 0 </span><span class="cov8" title="1">{
                mod := new(big.Int)
                x.DivMod(x, base, mod)
                result = append(result, base58Alphabet[mod.Int64()])
        }</span>

        // Add leading zeros (in base58 form)
        <span class="cov8" title="1">for _, b := range data </span><span class="cov8" title="1">{
                if b != 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">result = append(result, base58Alphabet[0])</span>
        }

        // Reverse the result
        <span class="cov8" title="1">for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                result[i], result[j] = result[j], result[i]
        }</span>

        <span class="cov8" title="1">return string(result)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package client

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "os"
        "time"

        pb "github.com/bittensor-lab/btsigner/proto/signer/v1"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/emptypb"
)

// ClientOptions holds configuration options for the signer client
type ClientOptions struct {
        Address            string
        TLSEnabled         bool
        CAPath             string
        CertPath           string
        KeyPath            string
        ServerNameOverride string
        Timeout            time.Duration
}

// DefaultClientOptions returns default client options
func DefaultClientOptions() *ClientOptions <span class="cov8" title="1">{
        return &amp;ClientOptions{
                Address:    "localhost:50051",
                TLSEnabled: false,
                Timeout:    5 * time.Second,
        }
}</span>

// SignerClient is a client for the remote signer
type SignerClient struct {
        conn   *grpc.ClientConn
        client pb.RemoteSignerClient
        opts   *ClientOptions
}

// NewSignerClient creates a new signer client
func NewSignerClient(opts *ClientOptions) (*SignerClient, error) <span class="cov8" title="1">{
        var dialOpts []grpc.DialOption

        if opts.TLSEnabled </span><span class="cov8" title="1">{
                var tlsConfig tls.Config

                if opts.CAPath != "" </span><span class="cov8" title="1">{
                        caCert, err := os.ReadFile(opts.CAPath)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to read CA cert: %w", err)
                        }</span>

                        <span class="cov8" title="1">certPool := x509.NewCertPool()
                        if !certPool.AppendCertsFromPEM(caCert) </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to add CA cert to pool")
                        }</span>

                        <span class="cov8" title="1">tlsConfig.RootCAs = certPool</span>
                }

                <span class="cov8" title="1">if opts.CertPath != "" </span><span class="cov8" title="1">{
                        cert, err := tls.LoadX509KeyPair(opts.CertPath, opts.KeyPath)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to load client cert: %w", err)
                        }</span>
                        <span class="cov8" title="1">tlsConfig.Certificates = []tls.Certificate{cert}</span>
                }

                <span class="cov8" title="1">if opts.ServerNameOverride != "" </span><span class="cov8" title="1">{
                        tlsConfig.ServerName = opts.ServerNameOverride
                }</span>

                <span class="cov8" title="1">creds := credentials.NewTLS(&amp;tlsConfig)
                dialOpts = append(dialOpts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov8" title="1"> {
                dialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))
        }</span>

        <span class="cov8" title="1">conn, err := grpc.Dial(opts.Address, dialOpts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to dial server: %w", err)
        }</span>

        <span class="cov8" title="1">client := pb.NewRemoteSignerClient(conn)

        return &amp;SignerClient{
                conn:   conn,
                client: client,
                opts:   opts,
        }, nil</span>
}

// GetPublicKey gets the public key from the remote signer
func (c *SignerClient) GetPublicKey(ctx context.Context) ([]byte, string, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, c.opts.Timeout)
        defer cancel()

        resp, err := c.client.GetPublicKey(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("failed to get public key: %w", err)
        }</span>

        <span class="cov8" title="1">return resp.PublicKey, resp.Ss58Address, nil</span>
}

// SignExtrinsic signs a payload using the remote signer
func (c *SignerClient) SignExtrinsic(ctx context.Context, payload []byte) ([]byte, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, c.opts.Timeout)
        defer cancel()

        resp, err := c.client.SignExtrinsic(ctx, &amp;pb.SignExtrinsicRequest{
                Payload: payload,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to sign payload: %w", err)
        }</span>

        <span class="cov8" title="1">return resp.Signature, nil</span>
}

// SignExtrinsicWithKey signs a payload using a specific key on the remote signer
func (c *SignerClient) SignExtrinsicWithKey(ctx context.Context, keyID string, payload []byte) ([]byte, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, c.opts.Timeout)
        defer cancel()

        // Since we don't have the SignExtrinsicWithKey RPC yet, we'll use the context field to pass the key ID
        resp, err := c.client.SignExtrinsic(ctx, &amp;pb.SignExtrinsicRequest{
                Payload: payload,
                Context: []byte(keyID),
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to sign payload with key %s: %w", keyID, err)
        }</span>

        <span class="cov8" title="1">return resp.Signature, nil</span>
}

// CheckHealth checks the health of the remote signer
func (c *SignerClient) CheckHealth(ctx context.Context) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, c.opts.Timeout)
        defer cancel()

        _, err := c.client.Health(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("health check failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Close closes the client connection
func (c *SignerClient) Close() error <span class="cov8" title="1">{
        if c.conn != nil </span><span class="cov8" title="1">{
                return c.conn.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package server

import (
        "context"
        "sync"

        "google.golang.org/grpc/health/grpc_health_v1"
)

// HealthServer implements the gRPC Health Checking Protocol
type HealthServer struct {
        grpc_health_v1.UnimplementedHealthServer
        mu     sync.RWMutex
        status grpc_health_v1.HealthCheckResponse_ServingStatus
}

// NewHealthServer creates a new health server
func NewHealthServer() *HealthServer <span class="cov8" title="1">{
        return &amp;HealthServer{
                status: grpc_health_v1.HealthCheckResponse_SERVING,
        }
}</span>

// Check implements the Check method from the gRPC Health Checking Protocol
func (s *HealthServer) Check(ctx context.Context, req *grpc_health_v1.HealthCheckRequest) (*grpc_health_v1.HealthCheckResponse, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        return &amp;grpc_health_v1.HealthCheckResponse{
                Status: s.status,
        }, nil
}</span>

// SetServingStatus sets the serving status of the health server
func (s *HealthServer) SetServingStatus(status grpc_health_v1.HealthCheckResponse_ServingStatus) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.status = status
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "context"
        "fmt"
        "net"
        "time"

        "github.com/bittensor-lab/btsigner/internal/config"
        "github.com/bittensor-lab/btsigner/pkg/signer"
        pb "github.com/bittensor-lab/btsigner/proto/signer/v1"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/keepalive"
        "google.golang.org/grpc/reflection"
        "google.golang.org/protobuf/types/known/emptypb"
)

// Server implements the RemoteSigner gRPC service
type Server struct {
        pb.UnimplementedRemoteSignerServer
        signer signer.Signer
        config *config.Config
        logger *zap.Logger
}

// NewServer creates a new server instance
func NewServer(signerImpl signer.Signer, cfg *config.Config, logger *zap.Logger) *Server <span class="cov8" title="1">{
        return &amp;Server{
                signer: signerImpl,
                config: cfg,
                logger: logger,
        }
}</span>

// Run starts the gRPC server
func (s *Server) Run() error <span class="cov0" title="0">{
        // Create listener
        lis, err := net.Listen("tcp", s.config.Server.Address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %w", err)
        }</span>

        // Configure server options
        <span class="cov0" title="0">var opts []grpc.ServerOption
        opts = append(opts, grpc.KeepaliveParams(keepalive.ServerParameters{
                MaxConnectionIdle: 5 * time.Minute,
                Time:              1 * time.Minute,
                Timeout:           20 * time.Second,
        }))

        // Configure TLS if enabled
        if s.config.TLS.Enabled </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(
                        s.config.TLS.CertPath,
                        s.config.TLS.KeyPath,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load TLS credentials: %w", err)
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        // Create gRPC server
        <span class="cov0" title="0">grpcServer := grpc.NewServer(opts...)

        // Register services
        pb.RegisterRemoteSignerServer(grpcServer, s)
        healthServer := NewHealthServer()
        grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)
        reflection.Register(grpcServer)

        // Start server
        s.logger.Info("Starting gRPC server", zap.String("address", s.config.Server.Address))
        return grpcServer.Serve(lis)</span>
}

// GetPublicKey returns the public key of the signer
func (s *Server) GetPublicKey(ctx context.Context, _ *emptypb.Empty) (*pb.GetPublicKeyResponse, error) <span class="cov8" title="1">{
        pubKey, ss58Addr, err := s.signer.GetPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get public key", zap.Error(err))
                return nil, err
        }</span>

        // Get key ID if available
        <span class="cov8" title="1">keyID := ""
        if ksSigner, ok := s.signer.(*signer.KeyStoreSigner); ok </span><span class="cov0" title="0">{
                keyID = ksSigner.DefaultKeyID()
                s.logger.Info("Using key",
                        zap.String("key_id", keyID),
                        zap.String("ss58_address", ss58Addr))
        }</span>

        <span class="cov8" title="1">return &amp;pb.GetPublicKeyResponse{
                PublicKey:   pubKey,
                Ss58Address: ss58Addr,
                KeyId:       keyID,
        }, nil</span>
}

// GetPublicKeyByID returns the public key of a specific signer by ID
func (s *Server) GetPublicKeyByID(ctx context.Context, req *pb.GetPublicKeyByIDRequest) (*pb.GetPublicKeyResponse, error) <span class="cov8" title="1">{
        if req.KeyId == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("key_id cannot be empty")
        }</span>

        // Check if we have a KeyStoreSigner
        <span class="cov8" title="1">ksSigner, ok := s.signer.(*signer.KeyStoreSigner)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("keystore signer not available")
        }</span>

        <span class="cov8" title="1">pubKey, ss58Addr, err := ksSigner.GetPublicKeyByID(req.KeyId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get public key by ID",
                        zap.String("key_id", req.KeyId),
                        zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.Info("Retrieved public key",
                zap.String("key_id", req.KeyId),
                zap.String("ss58_address", ss58Addr))

        return &amp;pb.GetPublicKeyResponse{
                PublicKey:   pubKey,
                Ss58Address: ss58Addr,
                KeyId:       req.KeyId,
        }, nil</span>
}

// SignExtrinsic signs a payload with the signer's private key
func (s *Server) SignExtrinsic(ctx context.Context, req *pb.SignExtrinsicRequest) (*pb.SignExtrinsicResponse, error) <span class="cov8" title="1">{
        if len(req.Payload) == 0 </span><span class="cov8" title="1">{
                s.logger.Error("Empty payload received")
                return nil, fmt.Errorf("payload cannot be empty")
        }</span>

        // Check if we have a KeyStoreSigner
        <span class="cov8" title="1">keyID := ""
        if ksSigner, ok := s.signer.(*signer.KeyStoreSigner); ok </span><span class="cov0" title="0">{
                keyID = ksSigner.DefaultKeyID()
                s.logger.Info("Signing with default key", zap.String("key_id", keyID))
        }</span>

        // Default signing with default key
        <span class="cov8" title="1">signature, err := s.signer.Sign(ctx, req.Payload)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to sign payload", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pb.SignExtrinsicResponse{
                Signature: signature,
                KeyId:     keyID,
        }, nil</span>
}

// SignExtrinsicWithKey signs a payload with a specific signer's private key
func (s *Server) SignExtrinsicWithKey(ctx context.Context, req *pb.SignExtrinsicWithKeyRequest) (*pb.SignExtrinsicResponse, error) <span class="cov8" title="1">{
        if len(req.Payload) == 0 </span><span class="cov8" title="1">{
                s.logger.Error("Empty payload received")
                return nil, fmt.Errorf("payload cannot be empty")
        }</span>

        <span class="cov8" title="1">if req.KeyId == "" </span><span class="cov8" title="1">{
                s.logger.Error("Empty key ID received")
                return nil, fmt.Errorf("key_id cannot be empty")
        }</span>

        // Check if we have a KeyStoreSigner
        <span class="cov8" title="1">ksSigner, ok := s.signer.(*signer.KeyStoreSigner)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("keystore signer not available")
        }</span>

        <span class="cov8" title="1">s.logger.Info("Signing with specific key", zap.String("key_id", req.KeyId))
        signature, err := ksSigner.SignWithKey(ctx, req.KeyId, req.Payload)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to sign with key",
                        zap.String("key_id", req.KeyId),
                        zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pb.SignExtrinsicResponse{
                Signature: signature,
                KeyId:     req.KeyId,
        }, nil</span>
}

// ListKeys returns a list of all available key IDs
func (s *Server) ListKeys(ctx context.Context, _ *emptypb.Empty) (*pb.ListKeysResponse, error) <span class="cov8" title="1">{
        // Check if we have a KeyStoreSigner
        ksSigner, ok := s.signer.(*signer.KeyStoreSigner)
        if !ok </span><span class="cov8" title="1">{
                // For single key signers, return empty list
                return &amp;pb.ListKeysResponse{
                        KeyIds:       []string{},
                        DefaultKeyId: "",
                }, nil
        }</span>

        <span class="cov8" title="1">keyIDs := ksSigner.ListKeyIDs()
        defaultKeyID := ksSigner.DefaultKeyID()

        s.logger.Info("Listed keys",
                zap.Strings("key_ids", keyIDs),
                zap.String("default_key_id", defaultKeyID))

        return &amp;pb.ListKeysResponse{
                KeyIds:       keyIDs,
                DefaultKeyId: defaultKeyID,
        }, nil</span>
}

// Health implements the health check endpoint
func (s *Server) Health(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov8" title="1">{
        return &amp;emptypb.Empty{}, nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package signer

import (
        "context"
        "errors"
        "fmt"

        "github.com/bittensor-lab/btsigner/internal/crypto"
)

var (
        ErrNoDefaultKeyID = errors.New("no default key ID specified")
)

// KeyStoreSigner implements the Signer interface using a KeyStore
type KeyStoreSigner struct {
        keyStore     *crypto.KeyStore
        defaultKeyID string
}

// NewKeyStoreSigner creates a new signer that uses a KeyStore
func NewKeyStoreSigner(keyStorePath string) (*KeyStoreSigner, error) <span class="cov8" title="1">{
        keyStore, err := crypto.NewKeyStore(keyStorePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create key store: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;KeyStoreSigner{
                keyStore: keyStore,
        }, nil</span>
}

// SetDefaultKeyID sets the default key ID to use for signing
func (s *KeyStoreSigner) SetDefaultKeyID(id string) <span class="cov8" title="1">{
        s.defaultKeyID = id
}</span>

// DefaultKeyID returns the current default key ID
func (s *KeyStoreSigner) DefaultKeyID() string <span class="cov8" title="1">{
        return s.defaultKeyID
}</span>

// LoadKey loads a key with the given ID and password
func (s *KeyStoreSigner) LoadKey(id string, password []byte) error <span class="cov8" title="1">{
        _, err := s.keyStore.LoadKey(id, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If this is the first key loaded, set it as default
        <span class="cov8" title="1">if s.defaultKeyID == "" </span><span class="cov0" title="0">{
                s.defaultKeyID = id
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GenerateKey generates a new key with the given ID and password
func (s *KeyStoreSigner) GenerateKey(id string, password []byte) error <span class="cov8" title="1">{
        _, err := s.keyStore.GenerateKey(id, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If this is the first key generated, set it as default
        <span class="cov8" title="1">if s.defaultKeyID == "" </span><span class="cov8" title="1">{
                s.defaultKeyID = id
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UnloadKey unloads a key from memory
func (s *KeyStoreSigner) UnloadKey(id string) error <span class="cov8" title="1">{
        return s.keyStore.UnloadKey(id)
}</span>

// DeleteKey permanently deletes a key
func (s *KeyStoreSigner) DeleteKey(id string) error <span class="cov8" title="1">{
        return s.keyStore.DeleteKey(id)
}</span>

// ListKeyIDs returns a list of all key IDs in the store
func (s *KeyStoreSigner) ListKeyIDs() []string <span class="cov8" title="1">{
        return s.keyStore.ListKeyIDs()
}</span>

// GetPublicKey implements Signer.GetPublicKey using the default key
func (s *KeyStoreSigner) GetPublicKey() ([]byte, string, error) <span class="cov8" title="1">{
        if s.defaultKeyID == "" </span><span class="cov8" title="1">{
                return nil, "", ErrNoDefaultKeyID
        }</span>

        <span class="cov8" title="1">return s.GetPublicKeyByID(s.defaultKeyID)</span>
}

// GetPublicKeyByID returns the public key for a specific key ID
func (s *KeyStoreSigner) GetPublicKeyByID(id string) ([]byte, string, error) <span class="cov8" title="1">{
        return s.keyStore.GetKeyInfo(id)
}</span>

// Sign implements Signer.Sign using the default key
func (s *KeyStoreSigner) Sign(ctx context.Context, payload []byte) ([]byte, error) <span class="cov8" title="1">{
        if s.defaultKeyID == "" </span><span class="cov8" title="1">{
                return nil, ErrNoDefaultKeyID
        }</span>

        <span class="cov8" title="1">return s.SignWithKey(ctx, s.defaultKeyID, payload)</span>
}

// SignWithKey signs a payload with a specific key
func (s *KeyStoreSigner) SignWithKey(ctx context.Context, id string, payload []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(payload) == 0 </span><span class="cov8" title="1">{
                return nil, ErrInvalidPayload
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        // Get the key
        <span class="cov8" title="1">keyPair, err := s.keyStore.LoadKey(id, nil) // Password not needed as key is already loaded
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Sign the payload
        <span class="cov8" title="1">signature, err := keyPair.Sign(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrSigningFailed
        }</span>

        <span class="cov8" title="1">return signature, nil</span>
}

// Close implements Signer.Close
func (s *KeyStoreSigner) Close() error <span class="cov8" title="1">{
        return s.keyStore.Close()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package signer

import (
        "context"
        "errors"

        "github.com/bittensor-lab/btsigner/internal/crypto"
)

var (
        ErrInvalidPayload = errors.New("invalid payload")
        ErrSigningFailed  = errors.New("signing failed")
        ErrKeyNotLoaded   = errors.New("key not loaded")
)

// Signer defines the interface for signing operations
type Signer interface {
        // GetPublicKey returns the public key as bytes and SS58 address
        GetPublicKey() ([]byte, string, error)

        // Sign signs a payload with the private key
        Sign(ctx context.Context, payload []byte) ([]byte, error)

        // Close releases any resources held by the signer
        Close() error
}

// Sr25519Signer implements the Signer interface using sr25519
type Sr25519Signer struct {
        keyPair *crypto.Sr25519KeyPair
}

// NewSr25519Signer creates a new sr25519 signer
func NewSr25519Signer(keyPath string, password []byte) (*Sr25519Signer, error) <span class="cov8" title="1">{
        keyPair, err := crypto.LoadSr25519KeyPair(keyPath, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Sr25519Signer{
                keyPair: keyPair,
        }, nil</span>
}

// GetPublicKey implements Signer.GetPublicKey
func (s *Sr25519Signer) GetPublicKey() ([]byte, string, error) <span class="cov8" title="1">{
        if s.keyPair == nil </span><span class="cov0" title="0">{
                return nil, "", ErrKeyNotLoaded
        }</span>

        <span class="cov8" title="1">pubKey := s.keyPair.PublicKey()
        ss58Addr, err := crypto.PublicKeyToSS58(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                return pubKey, "", err
        }</span>

        <span class="cov8" title="1">return pubKey, ss58Addr, nil</span>
}

// Sign implements Signer.Sign
func (s *Sr25519Signer) Sign(ctx context.Context, payload []byte) ([]byte, error) <span class="cov8" title="1">{
        if s.keyPair == nil </span><span class="cov0" title="0">{
                return nil, ErrKeyNotLoaded
        }</span>

        <span class="cov8" title="1">if len(payload) == 0 </span><span class="cov8" title="1">{
                return nil, ErrInvalidPayload
        }</span>

        // Check for context cancellation
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">signature, err := s.keyPair.Sign(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrSigningFailed
        }</span>

        <span class="cov8" title="1">return signature, nil</span>
}

// Close implements Signer.Close
func (s *Sr25519Signer) Close() error <span class="cov8" title="1">{
        if s.keyPair != nil </span><span class="cov8" title="1">{
                return s.keyPair.Zero()
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: proto/signer.proto

package v1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// GetPublicKeyResponse contains the public key information
type GetPublicKeyResponse struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // 32-byte compressed Ristretto point
        PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
        // SS58 address derived from public_key
        Ss58Address string `protobuf:"bytes,2,opt,name=ss58_address,json=ss58Address,proto3" json:"ss58_address,omitempty"`
        // Key ID
        KeyId         string `protobuf:"bytes,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPublicKeyResponse) Reset() <span class="cov0" title="0">{
        *x = GetPublicKeyResponse{}
        mi := &amp;file_proto_signer_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPublicKeyResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPublicKeyResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPublicKeyResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_signer_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPublicKeyResponse.ProtoReflect.Descriptor instead.
func (*GetPublicKeyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_signer_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GetPublicKeyResponse) GetPublicKey() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PublicKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPublicKeyResponse) GetSs58Address() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ss58Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetPublicKeyResponse) GetKeyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KeyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetPublicKeyByIDRequest specifies which key ID to get
type GetPublicKeyByIDRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Key ID to get public key for
        KeyId         string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPublicKeyByIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetPublicKeyByIDRequest{}
        mi := &amp;file_proto_signer_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPublicKeyByIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPublicKeyByIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPublicKeyByIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_signer_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPublicKeyByIDRequest.ProtoReflect.Descriptor instead.
func (*GetPublicKeyByIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_signer_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetPublicKeyByIDRequest) GetKeyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KeyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// SignExtrinsicRequest contains the payload to sign with the default key
type SignExtrinsicRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // SCALE-encoded payload to be signed
        Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
        // Optional context for verification (nonce, era, etc.)
        Context       []byte `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SignExtrinsicRequest) Reset() <span class="cov0" title="0">{
        *x = SignExtrinsicRequest{}
        mi := &amp;file_proto_signer_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SignExtrinsicRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SignExtrinsicRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SignExtrinsicRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_signer_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SignExtrinsicRequest.ProtoReflect.Descriptor instead.
func (*SignExtrinsicRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_signer_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SignExtrinsicRequest) GetPayload() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Payload
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SignExtrinsicRequest) GetContext() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Context
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SignExtrinsicWithKeyRequest contains the payload to sign with a specific key
type SignExtrinsicWithKeyRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Key ID to use for signing
        KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
        // SCALE-encoded payload to be signed
        Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
        // Optional context for verification (nonce, era, etc.)
        Context       []byte `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SignExtrinsicWithKeyRequest) Reset() <span class="cov0" title="0">{
        *x = SignExtrinsicWithKeyRequest{}
        mi := &amp;file_proto_signer_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SignExtrinsicWithKeyRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SignExtrinsicWithKeyRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SignExtrinsicWithKeyRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_signer_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SignExtrinsicWithKeyRequest.ProtoReflect.Descriptor instead.
func (*SignExtrinsicWithKeyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_signer_proto_rawDescGZIP(), []int{3}
}</span>

func (x *SignExtrinsicWithKeyRequest) GetKeyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KeyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SignExtrinsicWithKeyRequest) GetPayload() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Payload
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SignExtrinsicWithKeyRequest) GetContext() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Context
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SignExtrinsicResponse contains the signature
type SignExtrinsicResponse struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // 64-byte sr25519 signature
        Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
        // Key ID used for signing
        KeyId         string `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SignExtrinsicResponse) Reset() <span class="cov0" title="0">{
        *x = SignExtrinsicResponse{}
        mi := &amp;file_proto_signer_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SignExtrinsicResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SignExtrinsicResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SignExtrinsicResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_signer_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SignExtrinsicResponse.ProtoReflect.Descriptor instead.
func (*SignExtrinsicResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_signer_proto_rawDescGZIP(), []int{4}
}</span>

func (x *SignExtrinsicResponse) GetSignature() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Signature
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SignExtrinsicResponse) GetKeyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KeyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ListKeysResponse contains a list of all available key IDs
type ListKeysResponse struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of key IDs
        KeyIds []string `protobuf:"bytes,1,rep,name=key_ids,json=keyIds,proto3" json:"key_ids,omitempty"`
        // Default key ID (if set)
        DefaultKeyId  string `protobuf:"bytes,2,opt,name=default_key_id,json=defaultKeyId,proto3" json:"default_key_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListKeysResponse) Reset() <span class="cov0" title="0">{
        *x = ListKeysResponse{}
        mi := &amp;file_proto_signer_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListKeysResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListKeysResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListKeysResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_signer_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListKeysResponse.ProtoReflect.Descriptor instead.
func (*ListKeysResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_signer_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ListKeysResponse) GetKeyIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KeyIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListKeysResponse) GetDefaultKeyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultKeyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_proto_signer_proto protoreflect.FileDescriptor

const file_proto_signer_proto_rawDesc = "" +
        "\n" +
        "\x12proto/signer.proto\x12\vbtsigner.v1\x1a\x1bgoogle/protobuf/empty.proto\"o\n" +
        "\x14GetPublicKeyResponse\x12\x1d\n" +
        "\n" +
        "public_key\x18\x01 \x01(\fR\tpublicKey\x12!\n" +
        "\fss58_address\x18\x02 \x01(\tR\vss58Address\x12\x15\n" +
        "\x06key_id\x18\x03 \x01(\tR\x05keyId\"0\n" +
        "\x17GetPublicKeyByIDRequest\x12\x15\n" +
        "\x06key_id\x18\x01 \x01(\tR\x05keyId\"J\n" +
        "\x14SignExtrinsicRequest\x12\x18\n" +
        "\apayload\x18\x01 \x01(\fR\apayload\x12\x18\n" +
        "\acontext\x18\x02 \x01(\fR\acontext\"h\n" +
        "\x1bSignExtrinsicWithKeyRequest\x12\x15\n" +
        "\x06key_id\x18\x01 \x01(\tR\x05keyId\x12\x18\n" +
        "\apayload\x18\x02 \x01(\fR\apayload\x12\x18\n" +
        "\acontext\x18\x03 \x01(\fR\acontext\"L\n" +
        "\x15SignExtrinsicResponse\x12\x1c\n" +
        "\tsignature\x18\x01 \x01(\fR\tsignature\x12\x15\n" +
        "\x06key_id\x18\x02 \x01(\tR\x05keyId\"Q\n" +
        "\x10ListKeysResponse\x12\x17\n" +
        "\akey_ids\x18\x01 \x03(\tR\x06keyIds\x12$\n" +
        "\x0edefault_key_id\x18\x02 \x01(\tR\fdefaultKeyId2\xf1\x03\n" +
        "\fRemoteSigner\x12I\n" +
        "\fGetPublicKey\x12\x16.google.protobuf.Empty\x1a!.btsigner.v1.GetPublicKeyResponse\x12[\n" +
        "\x10GetPublicKeyByID\x12$.btsigner.v1.GetPublicKeyByIDRequest\x1a!.btsigner.v1.GetPublicKeyResponse\x12V\n" +
        "\rSignExtrinsic\x12!.btsigner.v1.SignExtrinsicRequest\x1a\".btsigner.v1.SignExtrinsicResponse\x12d\n" +
        "\x14SignExtrinsicWithKey\x12(.btsigner.v1.SignExtrinsicWithKeyRequest\x1a\".btsigner.v1.SignExtrinsicResponse\x12A\n" +
        "\bListKeys\x12\x16.google.protobuf.Empty\x1a\x1d.btsigner.v1.ListKeysResponse\x128\n" +
        "\x06Health\x12\x16.google.protobuf.Empty\x1a\x16.google.protobuf.EmptyB3Z1github.com/bittensor-lab/btsigner/proto/signer/v1b\x06proto3"

var (
        file_proto_signer_proto_rawDescOnce sync.Once
        file_proto_signer_proto_rawDescData []byte
)

func file_proto_signer_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_signer_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_signer_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_signer_proto_rawDesc), len(file_proto_signer_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_signer_proto_rawDescData</span>
}

var file_proto_signer_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_proto_signer_proto_goTypes = []any{
        (*GetPublicKeyResponse)(nil),        // 0: btsigner.v1.GetPublicKeyResponse
        (*GetPublicKeyByIDRequest)(nil),     // 1: btsigner.v1.GetPublicKeyByIDRequest
        (*SignExtrinsicRequest)(nil),        // 2: btsigner.v1.SignExtrinsicRequest
        (*SignExtrinsicWithKeyRequest)(nil), // 3: btsigner.v1.SignExtrinsicWithKeyRequest
        (*SignExtrinsicResponse)(nil),       // 4: btsigner.v1.SignExtrinsicResponse
        (*ListKeysResponse)(nil),            // 5: btsigner.v1.ListKeysResponse
        (*emptypb.Empty)(nil),               // 6: google.protobuf.Empty
}
var file_proto_signer_proto_depIdxs = []int32{
        6, // 0: btsigner.v1.RemoteSigner.GetPublicKey:input_type -&gt; google.protobuf.Empty
        1, // 1: btsigner.v1.RemoteSigner.GetPublicKeyByID:input_type -&gt; btsigner.v1.GetPublicKeyByIDRequest
        2, // 2: btsigner.v1.RemoteSigner.SignExtrinsic:input_type -&gt; btsigner.v1.SignExtrinsicRequest
        3, // 3: btsigner.v1.RemoteSigner.SignExtrinsicWithKey:input_type -&gt; btsigner.v1.SignExtrinsicWithKeyRequest
        6, // 4: btsigner.v1.RemoteSigner.ListKeys:input_type -&gt; google.protobuf.Empty
        6, // 5: btsigner.v1.RemoteSigner.Health:input_type -&gt; google.protobuf.Empty
        0, // 6: btsigner.v1.RemoteSigner.GetPublicKey:output_type -&gt; btsigner.v1.GetPublicKeyResponse
        0, // 7: btsigner.v1.RemoteSigner.GetPublicKeyByID:output_type -&gt; btsigner.v1.GetPublicKeyResponse
        4, // 8: btsigner.v1.RemoteSigner.SignExtrinsic:output_type -&gt; btsigner.v1.SignExtrinsicResponse
        4, // 9: btsigner.v1.RemoteSigner.SignExtrinsicWithKey:output_type -&gt; btsigner.v1.SignExtrinsicResponse
        5, // 10: btsigner.v1.RemoteSigner.ListKeys:output_type -&gt; btsigner.v1.ListKeysResponse
        6, // 11: btsigner.v1.RemoteSigner.Health:output_type -&gt; google.protobuf.Empty
        6, // [6:12] is the sub-list for method output_type
        0, // [0:6] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_signer_proto_init() }</span>
func file_proto_signer_proto_init() <span class="cov0" title="0">{
        if File_proto_signer_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_signer_proto_rawDesc), len(file_proto_signer_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_signer_proto_goTypes,
                DependencyIndexes: file_proto_signer_proto_depIdxs,
                MessageInfos:      file_proto_signer_proto_msgTypes,
        }.Build()
        File_proto_signer_proto = out.File
        file_proto_signer_proto_goTypes = nil
        file_proto_signer_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: proto/signer.proto

package v1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        RemoteSigner_GetPublicKey_FullMethodName         = "/btsigner.v1.RemoteSigner/GetPublicKey"
        RemoteSigner_GetPublicKeyByID_FullMethodName     = "/btsigner.v1.RemoteSigner/GetPublicKeyByID"
        RemoteSigner_SignExtrinsic_FullMethodName        = "/btsigner.v1.RemoteSigner/SignExtrinsic"
        RemoteSigner_SignExtrinsicWithKey_FullMethodName = "/btsigner.v1.RemoteSigner/SignExtrinsicWithKey"
        RemoteSigner_ListKeys_FullMethodName             = "/btsigner.v1.RemoteSigner/ListKeys"
        RemoteSigner_Health_FullMethodName               = "/btsigner.v1.RemoteSigner/Health"
)

// RemoteSignerClient is the client API for RemoteSigner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RemoteSigner service definition
type RemoteSignerClient interface {
        // GetPublicKey returns the public key of the default signer
        GetPublicKey(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetPublicKeyResponse, error)
        // GetPublicKeyByID returns the public key of a specific signer by ID
        GetPublicKeyByID(ctx context.Context, in *GetPublicKeyByIDRequest, opts ...grpc.CallOption) (*GetPublicKeyResponse, error)
        // SignExtrinsic signs a payload with the default signer's private key
        SignExtrinsic(ctx context.Context, in *SignExtrinsicRequest, opts ...grpc.CallOption) (*SignExtrinsicResponse, error)
        // SignExtrinsicWithKey signs a payload with a specific signer's private key
        SignExtrinsicWithKey(ctx context.Context, in *SignExtrinsicWithKeyRequest, opts ...grpc.CallOption) (*SignExtrinsicResponse, error)
        // ListKeys returns a list of all available key IDs
        ListKeys(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListKeysResponse, error)
        // Health returns the health status of the signer
        Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type remoteSignerClient struct {
        cc grpc.ClientConnInterface
}

func NewRemoteSignerClient(cc grpc.ClientConnInterface) RemoteSignerClient <span class="cov0" title="0">{
        return &amp;remoteSignerClient{cc}
}</span>

func (c *remoteSignerClient) GetPublicKey(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetPublicKeyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPublicKeyResponse)
        err := c.cc.Invoke(ctx, RemoteSigner_GetPublicKey_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *remoteSignerClient) GetPublicKeyByID(ctx context.Context, in *GetPublicKeyByIDRequest, opts ...grpc.CallOption) (*GetPublicKeyResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPublicKeyResponse)
        err := c.cc.Invoke(ctx, RemoteSigner_GetPublicKeyByID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *remoteSignerClient) SignExtrinsic(ctx context.Context, in *SignExtrinsicRequest, opts ...grpc.CallOption) (*SignExtrinsicResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SignExtrinsicResponse)
        err := c.cc.Invoke(ctx, RemoteSigner_SignExtrinsic_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *remoteSignerClient) SignExtrinsicWithKey(ctx context.Context, in *SignExtrinsicWithKeyRequest, opts ...grpc.CallOption) (*SignExtrinsicResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SignExtrinsicResponse)
        err := c.cc.Invoke(ctx, RemoteSigner_SignExtrinsicWithKey_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *remoteSignerClient) ListKeys(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListKeysResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListKeysResponse)
        err := c.cc.Invoke(ctx, RemoteSigner_ListKeys_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *remoteSignerClient) Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, RemoteSigner_Health_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// RemoteSignerServer is the server API for RemoteSigner service.
// All implementations must embed UnimplementedRemoteSignerServer
// for forward compatibility.
//
// RemoteSigner service definition
type RemoteSignerServer interface {
        // GetPublicKey returns the public key of the default signer
        GetPublicKey(context.Context, *emptypb.Empty) (*GetPublicKeyResponse, error)
        // GetPublicKeyByID returns the public key of a specific signer by ID
        GetPublicKeyByID(context.Context, *GetPublicKeyByIDRequest) (*GetPublicKeyResponse, error)
        // SignExtrinsic signs a payload with the default signer's private key
        SignExtrinsic(context.Context, *SignExtrinsicRequest) (*SignExtrinsicResponse, error)
        // SignExtrinsicWithKey signs a payload with a specific signer's private key
        SignExtrinsicWithKey(context.Context, *SignExtrinsicWithKeyRequest) (*SignExtrinsicResponse, error)
        // ListKeys returns a list of all available key IDs
        ListKeys(context.Context, *emptypb.Empty) (*ListKeysResponse, error)
        // Health returns the health status of the signer
        Health(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
        mustEmbedUnimplementedRemoteSignerServer()
}

// UnimplementedRemoteSignerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRemoteSignerServer struct{}

func (UnimplementedRemoteSignerServer) GetPublicKey(context.Context, *emptypb.Empty) (*GetPublicKeyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPublicKey not implemented")
}</span>
func (UnimplementedRemoteSignerServer) GetPublicKeyByID(context.Context, *GetPublicKeyByIDRequest) (*GetPublicKeyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPublicKeyByID not implemented")
}</span>
func (UnimplementedRemoteSignerServer) SignExtrinsic(context.Context, *SignExtrinsicRequest) (*SignExtrinsicResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SignExtrinsic not implemented")
}</span>
func (UnimplementedRemoteSignerServer) SignExtrinsicWithKey(context.Context, *SignExtrinsicWithKeyRequest) (*SignExtrinsicResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SignExtrinsicWithKey not implemented")
}</span>
func (UnimplementedRemoteSignerServer) ListKeys(context.Context, *emptypb.Empty) (*ListKeysResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}</span>
func (UnimplementedRemoteSignerServer) Health(context.Context, *emptypb.Empty) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}</span>
func (UnimplementedRemoteSignerServer) mustEmbedUnimplementedRemoteSignerServer() {<span class="cov0" title="0">}</span>
func (UnimplementedRemoteSignerServer) testEmbeddedByValue()                      {<span class="cov0" title="0">}</span>

// UnsafeRemoteSignerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemoteSignerServer will
// result in compilation errors.
type UnsafeRemoteSignerServer interface {
        mustEmbedUnimplementedRemoteSignerServer()
}

func RegisterRemoteSignerServer(s grpc.ServiceRegistrar, srv RemoteSignerServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedRemoteSignerServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;RemoteSigner_ServiceDesc, srv)</span>
}

func _RemoteSigner_GetPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).GetPublicKey(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: RemoteSigner_GetPublicKey_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).GetPublicKey(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _RemoteSigner_GetPublicKeyByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPublicKeyByIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).GetPublicKeyByID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: RemoteSigner_GetPublicKeyByID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).GetPublicKeyByID(ctx, req.(*GetPublicKeyByIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _RemoteSigner_SignExtrinsic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SignExtrinsicRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).SignExtrinsic(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: RemoteSigner_SignExtrinsic_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).SignExtrinsic(ctx, req.(*SignExtrinsicRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _RemoteSigner_SignExtrinsicWithKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SignExtrinsicWithKeyRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).SignExtrinsicWithKey(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: RemoteSigner_SignExtrinsicWithKey_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).SignExtrinsicWithKey(ctx, req.(*SignExtrinsicWithKeyRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _RemoteSigner_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).ListKeys(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: RemoteSigner_ListKeys_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).ListKeys(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _RemoteSigner_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).Health(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: RemoteSigner_Health_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(RemoteSignerServer).Health(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// RemoteSigner_ServiceDesc is the grpc.ServiceDesc for RemoteSigner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemoteSigner_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "btsigner.v1.RemoteSigner",
        HandlerType: (*RemoteSignerServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetPublicKey",
                        Handler:    _RemoteSigner_GetPublicKey_Handler,
                },
                {
                        MethodName: "GetPublicKeyByID",
                        Handler:    _RemoteSigner_GetPublicKeyByID_Handler,
                },
                {
                        MethodName: "SignExtrinsic",
                        Handler:    _RemoteSigner_SignExtrinsic_Handler,
                },
                {
                        MethodName: "SignExtrinsicWithKey",
                        Handler:    _RemoteSigner_SignExtrinsicWithKey_Handler,
                },
                {
                        MethodName: "ListKeys",
                        Handler:    _RemoteSigner_ListKeys_Handler,
                },
                {
                        MethodName: "Health",
                        Handler:    _RemoteSigner_Health_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/signer.proto",
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "context"
        "crypto/rand"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/bittensor-lab/btsigner/internal/crypto"
        "github.com/bittensor-lab/btsigner/pkg/signer"
)

const (
        // Test password for key generation
        testPassword = "test-password-123"
        
        // Test key paths
        singleKeyPath = "test_single_key.json"
        keystorePath  = "test_keystore"
)

// TestResult represents the result of a test
type TestResult struct {
        Name        string
        Success     bool
        Error       error
        Duration    time.Duration
        PublicKey   []byte
        SS58Address string
        Signature   []byte
}

// TestSuite manages and runs all tests
type TestSuite struct {
        results []TestResult
}

func (ts *TestSuite) addResult(result TestResult) <span class="cov0" title="0">{
        ts.results = append(ts.results, result)
}</span>

func (ts *TestSuite) printResults() <span class="cov0" title="0">{
        fmt.Println("\n" + strings.Repeat("=", 60))
        fmt.Println("TEST RESULTS SUMMARY")
        fmt.Println(strings.Repeat("=", 60))
        
        passed := 0
        failed := 0
        
        for _, result := range ts.results </span><span class="cov0" title="0">{
                status := " PASS"
                if !result.Success </span><span class="cov0" title="0">{
                        status = " FAIL"
                        failed++
                }</span> else<span class="cov0" title="0"> {
                        passed++
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("%s | %s | %v\n", status, result.Name, result.Duration)
                
                if result.PublicKey != nil </span><span class="cov0" title="0">{
                        fmt.Printf("     Public Key: %x\n", result.PublicKey)
                }</span>
                <span class="cov0" title="0">if result.SS58Address != "" </span><span class="cov0" title="0">{
                        fmt.Printf("     SS58 Address: %s\n", result.SS58Address)
                }</span>
                <span class="cov0" title="0">if result.Signature != nil </span><span class="cov0" title="0">{
                        fmt.Printf("     Signature: %x\n", result.Signature)
                }</span>
                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                        fmt.Printf("     Error: %v\n", result.Error)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        
        <span class="cov0" title="0">fmt.Printf("Total: %d | Passed: %d | Failed: %d\n", len(ts.results), passed, failed)
        fmt.Println(strings.Repeat("=", 60))</span>
}

func main() <span class="cov0" title="0">{
        fmt.Println("Bittensor Signer Key Generation and Signing Test Suite")
        fmt.Println(strings.Repeat("=", 60))
        
        ts := &amp;TestSuite{}
        
        // Clean up any existing test files
        cleanup()
        defer cleanup()
        
        // Test 1: Single Key Generation
        ts.testSingleKeyGeneration()
        
        // Test 2: Single Key Signing
        ts.testSingleKeySigning()
        
        // Test 3: Keystore Creation and Key Generation
        ts.testKeystoreGeneration()
        
        // Test 4: Multiple Keys in Keystore
        ts.testMultipleKeysInKeystore()
        
        // Test 5: Keystore Signing
        ts.testKeystoreSigning()
        
        // Test 6: Stress Test - Multiple Signatures
        ts.testStressSignatures()
        
        // Test 7: Edge Cases
        ts.testEdgeCases()
        
        // Print final results
        ts.printResults()
}</span>

func (ts *TestSuite) testSingleKeyGeneration() <span class="cov0" title="0">{
        start := time.Now()
        result := TestResult{
                Name:      "Single Key Generation",
                Success:   false,
                Duration:  0,
        }
        
        fmt.Println("Test 1: Single Key Generation")
        fmt.Println(strings.Repeat("-", 30))
        
        // Generate a single key
        keyPair, err := crypto.GenerateKeyFile(singleKeyPath, []byte(testPassword))
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to generate key: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        
        // Get public key and SS58 address
        <span class="cov0" title="0">pubKey := keyPair.PublicKey()
        ss58Addr, err := crypto.PublicKeyToSS58(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to convert to SS58: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        
        <span class="cov0" title="0">result.Success = true
        result.PublicKey = pubKey
        result.SS58Address = ss58Addr
        result.Duration = time.Since(start)
        
        fmt.Printf(" Generated single key successfully\n")
        fmt.Printf("  Public Key: %x\n", pubKey)
        fmt.Printf("  SS58 Address: %s\n", ss58Addr)
        fmt.Printf("  Duration: %v\n", result.Duration)
        
        ts.addResult(result)</span>
}

func (ts *TestSuite) testSingleKeySigning() <span class="cov0" title="0">{
        start := time.Now()
        result := TestResult{
                Name:      "Single Key Signing",
                Success:   false,
                Duration:  0,
        }
        
        fmt.Println("\nTest 2: Single Key Signing")
        fmt.Println(strings.Repeat("-", 30))
        
        // Load the previously generated key
        s, err := signer.NewSr25519Signer(singleKeyPath, []byte(testPassword))
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create signer: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">defer s.Close()
        
        // Get public key info
        pubKey, ss58Addr, err := s.GetPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to get public key: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        
        // Test signing with different payloads
        <span class="cov0" title="0">testPayloads := [][]byte{
                []byte("hello world"),
                []byte("test message for signing"),
                {0x01, 0x02, 0x03, 0x04, 0x05}, // binary data
        }
        
        ctx := context.Background()
        var lastSignature []byte
        
        for i, payload := range testPayloads </span><span class="cov0" title="0">{
                signature, err := s.Sign(ctx, payload)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to sign payload %d: %w", i, err)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                <span class="cov0" title="0">if len(signature) == 0 </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("signature %d is empty", i)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                <span class="cov0" title="0">lastSignature = signature
                fmt.Printf(" Signed payload %d: %x -&gt; %x\n", i+1, payload, signature)</span>
        }
        
        <span class="cov0" title="0">result.Success = true
        result.PublicKey = pubKey
        result.SS58Address = ss58Addr
        result.Signature = lastSignature
        result.Duration = time.Since(start)
        
        fmt.Printf(" Single key signing test passed\n")
        fmt.Printf("  Duration: %v\n", result.Duration)
        
        ts.addResult(result)</span>
}

func (ts *TestSuite) testKeystoreGeneration() <span class="cov0" title="0">{
        start := time.Now()
        result := TestResult{
                Name:      "Keystore Generation",
                Success:   false,
                Duration:  0,
        }
        
        fmt.Println("\nTest 3: Keystore Generation")
        fmt.Println(strings.Repeat("-", 30))
        
        // Create keystore signer
        ksSigner, err := signer.NewKeyStoreSigner(keystorePath)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create keystore signer: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">defer ksSigner.Close()
        
        // Generate a key in the keystore
        keyID := "test-key-1"
        err = ksSigner.GenerateKey(keyID, []byte(testPassword))
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to generate key in keystore: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        
        // Get public key info
        <span class="cov0" title="0">pubKey, ss58Addr, err := ksSigner.GetPublicKeyByID(keyID)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to get public key by ID: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        
        <span class="cov0" title="0">result.Success = true
        result.PublicKey = pubKey
        result.SS58Address = ss58Addr
        result.Duration = time.Since(start)
        
        fmt.Printf(" Generated keystore key successfully\n")
        fmt.Printf("  Key ID: %s\n", keyID)
        fmt.Printf("  Public Key: %x\n", pubKey)
        fmt.Printf("  SS58 Address: %s\n", ss58Addr)
        fmt.Printf("  Duration: %v\n", result.Duration)
        
        ts.addResult(result)</span>
}

func (ts *TestSuite) testMultipleKeysInKeystore() <span class="cov0" title="0">{
        start := time.Now()
        result := TestResult{
                Name:      "Multiple Keys in Keystore",
                Success:   false,
                Duration:  0,
        }
        
        fmt.Println("\nTest 4: Multiple Keys in Keystore")
        fmt.Println(strings.Repeat("-", 30))
        
        // Create keystore signer
        ksSigner, err := signer.NewKeyStoreSigner(keystorePath)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create keystore signer: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">defer ksSigner.Close()
        
        // Generate multiple keys
        keyIDs := []string{"validator-key", "cold-key", "hot-key"}
        
        for _, keyID := range keyIDs </span><span class="cov0" title="0">{
                err = ksSigner.GenerateKey(keyID, []byte(testPassword))
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to generate key %s: %w", keyID, err)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                // Get public key info
                <span class="cov0" title="0">pubKey, ss58Addr, err := ksSigner.GetPublicKeyByID(keyID)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to get public key for %s: %w", keyID, err)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                <span class="cov0" title="0">fmt.Printf(" Generated key: %s\n", keyID)
                fmt.Printf("  Public Key: %x\n", pubKey)
                fmt.Printf("  SS58 Address: %s\n", ss58Addr)</span>
        }
        
        // List all keys
        <span class="cov0" title="0">allKeyIDs := ksSigner.ListKeyIDs()
        fmt.Printf(" Total keys in keystore: %d\n", len(allKeyIDs))
        fmt.Printf("  Key IDs: %v\n", allKeyIDs)
        
        result.Success = true
        result.Duration = time.Since(start)
        
        ts.addResult(result)</span>
}

func (ts *TestSuite) testKeystoreSigning() <span class="cov0" title="0">{
        start := time.Now()
        result := TestResult{
                Name:      "Keystore Signing",
                Success:   false,
                Duration:  0,
        }
        
        fmt.Println("\nTest 5: Keystore Signing")
        fmt.Println(strings.Repeat("-", 30))
        
        // Create keystore signer
        ksSigner, err := signer.NewKeyStoreSigner(keystorePath)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create keystore signer: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">defer ksSigner.Close()
        
        // Load keys (they should already exist from previous tests)
        keyIDs := []string{"test-key-1", "validator-key", "cold-key", "hot-key"}
        
        for _, keyID := range keyIDs </span><span class="cov0" title="0">{
                err = ksSigner.LoadKey(keyID, []byte(testPassword))
                if err != nil </span><span class="cov0" title="0">{
                        // Skip if key doesn't exist
                        continue</span>
                }
                
                // Test signing with this key
                <span class="cov0" title="0">payload := []byte(fmt.Sprintf("test message for key %s", keyID))
                ctx := context.Background()
                
                signature, err := ksSigner.SignWithKey(ctx, keyID, payload)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to sign with key %s: %w", keyID, err)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                <span class="cov0" title="0">if len(signature) == 0 </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("signature for key %s is empty", keyID)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                <span class="cov0" title="0">fmt.Printf(" Signed with key %s: %x\n", keyID, signature)
                result.Signature = signature</span>
        }
        
        <span class="cov0" title="0">result.Success = true
        result.Duration = time.Since(start)
        
        fmt.Printf(" Keystore signing test passed\n")
        fmt.Printf("  Duration: %v\n", result.Duration)
        
        ts.addResult(result)</span>
}

func (ts *TestSuite) testStressSignatures() <span class="cov0" title="0">{
        start := time.Now()
        result := TestResult{
                Name:      "Stress Test - 5000 Signatures",
                Success:   false,
                Duration:  0,
        }
        
        fmt.Println("\nTest 6: Stress Test - 5000 Signatures")
        fmt.Println(strings.Repeat("-", 30))
        
        // Load single key signer
        s, err := signer.NewSr25519Signer(singleKeyPath, []byte(testPassword))
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create signer: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">defer s.Close()
        
        // Generate many random payloads and sign them
        numSignatures := 5000
        ctx := context.Background()
        
        for i := 0; i &lt; numSignatures; i++ </span><span class="cov0" title="0">{
                // Generate random payload
                payload := make([]byte, 32)
                rand.Read(payload)
                
                signature, err := s.Sign(ctx, payload)
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("failed to sign payload %d: %w", i, err)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                <span class="cov0" title="0">if len(signature) == 0 </span><span class="cov0" title="0">{
                        result.Error = fmt.Errorf("signature %d is empty", i)
                        result.Duration = time.Since(start)
                        ts.addResult(result)
                        return
                }</span>
                
                <span class="cov0" title="0">if i%500 == 0 </span><span class="cov0" title="0">{
                        fmt.Printf(" Completed %d/%d signatures\n", i+1, numSignatures)
                }</span>
        }
        
        <span class="cov0" title="0">result.Success = true
        result.Duration = time.Since(start)
        
        fmt.Printf(" Stress test passed - %d signatures in %v\n", numSignatures, result.Duration)
        fmt.Printf("  Average time per signature: %v\n", result.Duration/time.Duration(numSignatures))
        
        ts.addResult(result)</span>
}

func (ts *TestSuite) testEdgeCases() <span class="cov0" title="0">{
        start := time.Now()
        result := TestResult{
                Name:      "Edge Cases",
                Success:   false,
                Duration:  0,
        }
        
        fmt.Println("\nTest 7: Edge Cases")
        fmt.Println(strings.Repeat("-", 30))
        
        // Load single key signer
        s, err := signer.NewSr25519Signer(singleKeyPath, []byte(testPassword))
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to create signer: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">defer s.Close()
        
        ctx := context.Background()
        
        // Test 1: Empty payload (should fail)
        _, err = s.Sign(ctx, []byte{})
        if err == nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("expected error for empty payload, got nil")
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf(" Empty payload correctly rejected: %v\n", err)
        
        // Test 2: Cancelled context
        cancelCtx, cancel := context.WithCancel(context.Background())
        cancel()
        _, err = s.Sign(cancelCtx, []byte("test"))
        if err == nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("expected error for cancelled context, got nil")
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf(" Cancelled context correctly rejected: %v\n", err)
        
        // Test 3: Very large payload
        largePayload := make([]byte, 1024*1024) // 1MB
        rand.Read(largePayload)
        
        signature, err := s.Sign(ctx, largePayload)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to sign large payload: %w", err)
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        
        <span class="cov0" title="0">if len(signature) == 0 </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("signature for large payload is empty")
                result.Duration = time.Since(start)
                ts.addResult(result)
                return
        }</span>
        
        <span class="cov0" title="0">fmt.Printf(" Large payload (1MB) signed successfully\n")
        
        result.Success = true
        result.Duration = time.Since(start)
        result.Signature = signature
        
        fmt.Printf(" Edge cases test passed\n")
        fmt.Printf("  Duration: %v\n", result.Duration)
        
        ts.addResult(result)</span>
}

func cleanup() <span class="cov0" title="0">{
        // Remove test files
        os.Remove(singleKeyPath)
        os.RemoveAll(keystorePath)
}</span>

func init() <span class="cov0" title="0">{
        // Ensure we're in the right directory
        if _, err := os.Stat("go.mod"); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Please run this script from the root directory of the btsigner project")
                os.Exit(1)
        }</span>
} </pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
